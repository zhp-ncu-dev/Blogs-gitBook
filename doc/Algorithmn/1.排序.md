# ** 排序算法 **  
> ***根据 leetcode 上题目练习的积累，在排序算法这一块，主要涉及到归并排序、快排、桶排序、堆排序等。本节分别从这几块来讲解排序算法的原理和应用。***  

## 归并排序  
### 归并排序的原理   
![merge_sorting](../../../BlogRecord/picture/algorithmn/merge_sorting.gif)  

由上述动图可知，归并排序需要进行如下两个步骤：
1. 将数组分组，可以使用递归、迭代的方式进行；
2. 合并两个有序数组.    
下面分别从迭代、递归两种写法进行分析:

> merge 的步骤：  
1.申请空间，其大小为传递进来的两个序列空间大小之和，用于存放归并之后的结果；  
2.设定两个指针分别指向两个序列的起始位置；  
3.比较两个指针所指向的元素的大小，选择小的放入结果列表中，并移动指针到下一位；  
4.重复以上的步骤直到某一个指针到达序列结尾，将另一序列中剩余的元素直接复制到结果列表中。  

``` C++ 
template<typename T>
void merge(T arr[], int l, int mid, int r) {
  // 申请空间
  T aux[r - l + 1];
  for(int i = l; i <= r; ++i) aux[i - l] = arr[i];
  // 定义指针, i 指向左半部分的起始索引位置，j 指向右半部分起始索引位置。
  int i = l, j = mid + 1;
  for(int k = l; k <= r; ++k) {
    // 左半部分所指元素 < 右半部分所指元素
    if(aux[i - l] < aux[j - l])       { arr[k] = aux[i - l]; i ++; }
    // 左半部分所指元素 >= 右半部分所指元素
    else if(aux[i - l] >= aux[j - l]) { arr[k] = aux[j - l]; j ++; }
    // 左半部分处理完毕
    else if(i > mid)                  { arr[k] = aux[j - l]; j ++; }
    // 右半部分处理完毕
    else if(j > r)                    { arr[k] = aux[i - l]; i ++; }
  }
}
```  
#### 递归版本[自顶向下]  
``` C++  
template<typename T>
void mergeSort(T arr[], int l, int r) {
  int mid = l + (r - l)/2;
  // 划分数组
  mergeSort(arr, l, mid);
  mergeSort(arr, mid + 1, r);
  // 合并
  // 对 arr[mid] <= arr[mid + 1] 的情况，无需进行排序
  if(arr[mid] > arr[mid + 1]) merge(arr, l, mid, r);
}
template<typename T>
void mergeSort(T arr[], int n) {
  // n 为 arr 的长度
  mergeSort(arr, 0, n - 1);
}
```  
#### 迭代版本[自底向上]  
``` C++  
template<typename T>
void mergeSortBU(T arr[], int n) {
  for(int sz = 1; sz < n; sz += sz) {
    for(int i = 0; i < n - sz; i += sz + sz) {
      if(arr[i + sz - 1] > arr[i + sz]) 
        merge(arr, i, i + sz - 1, min(i + sz + sz - 1, n - 1));
    }
  }
}
```  
### Leetcode 案例分析  




